{"version":3,"sources":["Color.tsx","VertexColor.tsx","Vertex.tsx","Edge.tsx","Step.tsx","GUI.tsx","Graph.tsx","Board.tsx","App.tsx","index.tsx"],"names":["Color","VertexColor","props","obj","colorRef","state","JSON","parse","stringify","React","createRef","e","preventDefault","console","log","color","div","this","current","setColor","style","backgroundColor","background","vertexId","ref","className","onMouseUp","vertexcolor_onmouse","onMouseDown","el","f","classList","add","offsetHeight","fadeTo","Default","Component","Vertex","index1","p","x","y","colorComponent","isStart","isGoal","setState","hitSpacer","Object","assign","render","reset","left","top","renderVertexColor","id","vertex_onmouse","spacer_onclick","totalEverMade","BackgroundMode","getPts","theta","r","width","x1","Math","cos","y1","sin","x2","tan","y2","SvgPath","paths","offX","offY","push","h1_x","h1_y","h2_x","h2_y","px","py","join","replaceAll","makePath","theta1","theta2","middle","l","moveTo","lineTo","curveTo","unroll","ColorError","name","mode","Error","AnimationType","Edge","clipStates","w","h","length","angle","clipState","color1","color2","backgroundMode","Solid","p1","p2","hypot","atan2","PI","setClipState","remove","lineDiv","querySelector","styleInstantly","backgroundImage","clipPath","fadeToSolid","speed","Gradient","gradient","makeGradientString","backgroundPositionX","onComplete","window","setTimeout","SPEED","styleInner","styleMain","transform","borderWidth","borderColor","GUI","onclick_editmode","up","set","target","textContent","toUpperCase","onclick_mode","onclick_runmode","onclick_run","run","onclick_speed","speedMS","document","documentElement","setProperty","onClick","Graph","edges","size","edgeInfo","map","row","getIndex2","time","frames","animationType","FadeVertex","start","goal","seen","steps","fadeVertex","results","doSearch","from","stack","output","forEach","to","newStack","indexOf","s","index2","Red","SweepForward","found","Green","i","tos","BOARD_SIZE","Promise","prototype","delay","t","then","v","resolve","bind","Board","settings","mouseDownVertexId","fnName","vertices","editmode","testmode","key","value","newSettings","innerWidth","prevStart","prevStartVertex","getVertex","setStart","prevGoal","prevgoalVertex","setGoal","event","interpretMouseEvent","hitVertex","validLocation","addVertex","deleteVertex","flat","filter","Boolean","addEdge","position","default","index","splice","decrementIndex","edge","j","getIndex1","undefined","vertex","step","all","entry","animateStepEntry","reject","doSweep","reduce","curr","max","apply","frame","animateStep","getAllEdges","getAllVertices","graph","runDepthFirstSearch","Black","runBreadthFirstSearch","animateSteps","v1","v2","getEdge","animateSweep","sweepForward","getStart","getGoal","updateSetting","onmousedown","onmouseup","renderVertices","renderEdges","display","some","dim","PADDING_SIZE","nativeEvent","rect","getBoundingClientRect","pageX","pageY","clientX","clientY","getRelativeCoords","isValidLocation","App","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.f8c588f5.chunk.js","sourcesContent":["enum Color {\r\n    Default = \"#b8b8be\",\r\n    Black = \"#030b1f\",\r\n    Red = \"#16d867\",\r\n    Blue = \"#155cc7\",\r\n    Green = \"#16d867\",  \r\n  }\r\n\r\n  \r\nexport default Color;","import { url } from 'inspector';\r\nimport React from 'react';\r\nimport Color from './Color';\r\nimport { Vertex } from './Vertex';\r\n\r\nfunction copy<T>(obj: T) : T {\r\n    return JSON.parse(JSON.stringify(obj));\r\n}\r\n\r\ninterface VertexColorProps {\r\n    color: string;\r\n    vertexId: string;\r\n}\r\n\r\n\r\nclass VertexColor extends React.Component<VertexColorProps, VertexColorProps> {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = copy<VertexColorProps>(props);\r\n        this.colorRef = React.createRef();\r\n\r\n    }\r\n\r\n    colorRef;\r\n    vertexcolor_onmouse(e) {\r\n        e.preventDefault();\r\n    }\r\n\r\n    \r\n    componentDidMount() {\r\n        console.log(\"Mounted\");\r\n    }\r\n\r\n    fadeTo (color: string) {\r\n        const div = this.colorRef.current;\r\n        this.setColor(color);\r\n        div.style.backgroundColor = color;\r\n      \r\n    }   \r\n\r\n    \r\n    render() {\r\n        const style = {\r\n            background: this.state.color,\r\n            [\"clip-path\"]: `url(${this.state.vertexId})`,\r\n        }\r\n        return (\r\n            <div ref={this.colorRef} className=\"vertexColor\" style={style}\r\n            onMouseUp={(e) => this.vertexcolor_onmouse(e)}\r\n            onMouseDown={(e) => this.vertexcolor_onmouse(e)}\r\n            ></div>\r\n        )\r\n    }\r\n    styleInstantly(el: HTMLElement, f: Function) {\r\n        // https://stackoverflow.com/questions/11131875/what-is-the-cleanest-way-to-disable-css-transition-effects-temporarily\r\n        el.classList.add('notransition');\r\n        f();\r\n        let x = el.offsetHeight;\r\n    }\r\n    setColor(color: string) {\r\n        console.log(\"THIS\", this);\r\n        /*this.setState({color}, () => {\r\n            console.log(\"Set color to \", color, \", state now: \", this.state);\r\n        });*/\r\n        this.state = {color, vertexId: this.state.vertexId};\r\n        console.log(\"attempted set color\")\r\n    }\r\n\r\n    reset() {\r\n        const el = this.colorRef.current;\r\n       //this.styleInstantly(el, () => {\r\n        this.fadeTo(Color.Default);\r\n       // });\r\n    }\r\n}\r\n\r\nexport default VertexColor;","import React from 'react';\r\nimport VertexColor from './VertexColor';\r\nimport Color from './Color';\r\ninterface VertexProps {\r\n    p: {\r\n        x: number,\r\n        y: number,\r\n    },\r\n    color: string,\r\n    index1: number,\r\n    colorComponent: VertexColor,\r\n    isStart: boolean,\r\n    isGoal: boolean,\r\n}\r\n  \r\ninterface VertexState { \r\n    \r\n};\r\nfunction copy<T>(obj: T) : T {\r\n    return JSON.parse(JSON.stringify(obj));\r\n}\r\n\r\nclass Vertex extends React.Component<VertexProps, VertexProps> {\r\n\r\n    static default(index1: number, x: number, y: number) {\r\n        return new Vertex({\r\n            index1,\r\n            p: {\r\n                x, y,\r\n            },\r\n            color: Color.Default,\r\n            colorComponent: new VertexColor({color: Color.Default, vertexId: index1}),\r\n            isStart: false,\r\n        })\r\n    }\r\n\r\n    static totalEverMade: number = 0;\r\n    \r\n    colorRef;\r\n    constructor(props) {\r\n        super(props);\r\n        const {index1, p: {x, y}, color, colorComponent, isStart, isGoal } = props;\r\n        this.state = {\r\n            index1, p: {x, y}, color, colorComponent, isStart, isGoal,\r\n        }//;copy<VertexProps>(props); \r\n       // this.colorRef = React.createRef();\r\n    }\r\n\r\n    componentWillMount() {\r\n        this.fadeTo(\"orange\");\r\n    }\r\n    \r\n    decrementIndex() : void {\r\n        this.setState({index1: this.state.index1 - 1,})\r\n    }\r\n\r\n    setStart() : void {\r\n        if (this.state) {\r\n            this.setState({isStart: true}, function() {\r\n                console.log(\"set state successfully\");\r\n            });\r\n        } else {\r\n            //\r\n        }\r\n\r\n        console.log('tried to set state');\r\n    }\r\n\r\n    unsetStart() {\r\n        if (this.state) {\r\n            this.setState({isStart: false});\r\n        } else {\r\n            //this.state.isStart = false;\r\n        }\r\n    }\r\n\r\n    setGoal() : void {\r\n        if (this.state) {\r\n            this.setState({isGoal: true}, function() {\r\n                console.log(\"set state successfully\");\r\n            });\r\n        } else {\r\n            //\r\n        }\r\n\r\n        console.log('tried to set state');\r\n    }\r\n\r\n    unsetGoal() {\r\n        if (this.state) {\r\n            this.setState({isGoal: false});\r\n        } else {\r\n            //this.state.isStart = false;\r\n        }\r\n    }\r\n\r\n    \r\n    vertex_onmouse(e) : void {\r\n        //console.log(\"vertex  clicked: id \", this.props.index1);\r\n        e.preventDefault();\r\n        e.vertexId = this.props.index1;\r\n    }\r\n    \r\n    spacer_onclick(e) : void{\r\n      e.preventDefault();\r\n      e.hitSpacer = true;\r\n    }\r\n\r\n    fadeTo (color: string) {\r\n\r\n        this.state.colorComponent.fadeTo(color);\r\n       \r\n        const obj = {};\r\n        Object.assign(obj, this.state, {color});\r\n\r\n        this.state = obj as VertexProps;\r\n    }\r\n\r\n    renderVertexColor()  {\r\n        return this.props.colorComponent.render();\r\n    }\r\n\r\n    reset() {\r\n        this.state.colorComponent.reset();\r\n        this.setState({color: Color.Default });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                key={\"vertex\" + Vertex.totalEverMade++} \r\n                className=\"vertexOuter\"\r\n                style={{\r\n                    left: this.props.p.x,\r\n                    top: this.props.p.y,\r\n                }}\r\n            >\r\n              {this.renderVertexColor()}\r\n\r\n            <div className={\"vertex\" + (this.state.isStart ? \" startVertex\" : \"\")} id={\"vertex\" + this.props.index1} \r\n                onMouseUp={(e) => this.vertex_onmouse(e)}\r\n                onMouseDown={(e) => this.vertex_onmouse(e)}\r\n                \r\n            >\r\n                <div className=\"vertexSpacer\" onMouseDown={(e) => this.spacer_onclick(e)}></div>\r\n            </div>\r\n        \r\n        </div>\r\n      )\r\n    }\r\n}\r\n\r\nexport {\r\n    Vertex, Color\r\n};\r\n\r\n","import { NONAME } from 'dns';\r\nimport React from 'react';\r\nimport { NumberLiteralType } from 'typescript';\r\nimport { Vertex, Color } from './Vertex';\r\n\r\n\r\n// Default speed\r\nconst SPEED = 300;\r\n\r\n// bad version of deep copy. but works for most stuff.\r\nfunction copy<T>(obj: T) : T {\r\n    return JSON.parse(JSON.stringify(obj));\r\n  }\r\n\r\n  //I create the clip path data dynamically, based on the radius of a circle and the arc that the clip-path should cover\r\n  const getPts = (theta, r, width) => {\r\n    //let a = (r - width) / r;\r\n    return {\r\n        x1: r * Math.cos(theta),\r\n          y1: r * Math.sin(theta),\r\n          x2: r / Math.cos(theta) - Math.tan(theta) * width,\r\n          y2: width,\r\n      }\r\n  }\r\n  \r\n  //I create this svg class to more easily make my path strings.\r\n  class SvgPath {\r\n    \r\n    paths: string[] = [];\r\n    offX: number = 0;\r\n    offY: number = 0;\r\n\r\n      moveTo(x, y) : void {\r\n        this.paths.push(`M ${x + this.offX} ${y + this.offY}`);\r\n      };\r\n      \r\n      lineTo (x, y) : void {\r\n        this.paths.push(`L ${x + this.offX} ${y + this.offY}`);\r\n      }\r\n      \r\n      curveTo (h1_x, h1_y, h2_x, h2_y, px, py) : void {\r\n        this.paths.push(\"C \" + [h1_x + this.offX, h1_y + this.offY, h2_x + this.offX, h2_y + this.offY, px + this.offX, py + this.offY].join(' '));\r\n      }\r\n      unroll () : string {\r\n        return this.paths.join(' ').replaceAll(/\\.\\d+ /g, \" \");\r\n      }\r\n  }\r\n  \r\n  const makePath = function(theta1, theta2, middle, l, r, width) {\r\n     const p = new SvgPath();\r\n       p.offY = r;\r\n       (() => {\r\n       let { x1, y1, x2, y2} = getPts(theta1, r, width);\r\n       p.moveTo(0, 0);\r\n       p.lineTo(x1, y1);\r\n       p.curveTo(x2, y2, x2, y2, middle, width);\r\n       p.lineTo(middle, 0)\r\n       p.lineTo(0, 0);\r\n       p.lineTo(x1, -y1);\r\n       p.curveTo(x2, -y2, x2, -y2, middle, -width);\r\n       p.lineTo(middle, 0);\r\n       p.lineTo(0, 0);\r\n       })();\r\n       (() => {\r\n      const { x1, y1, x2, y2} = getPts(theta2, r, width);\r\n       p.moveTo(l, 0);\r\n       p.lineTo(l - x1, y1);\r\n       p.curveTo(l - x2, y2, l - x2, y2, middle, width);\r\n       p.lineTo(middle, 0);\r\n       p.lineTo(l, 0);\r\n       p.lineTo(l - x1, -y1);\r\n       p.curveTo(l - x2, -y2, l - x2, -y2, middle, -width);\r\n       p.lineTo(middle, 0);\r\n       p.lineTo(l, 0);\r\n       })();\r\n      \r\n       \r\n       return `path(nonzero, \"${p.unroll()}\")`;\r\n  }\r\n\r\ntype BackgroundEvent = Record<string, (color1: string, color2?: string) => void>;\r\n\r\n// Shouldn't ever get thrown, made for debugging, but will be thrown when color strings are improperly passed.\r\nclass ColorError extends Error {\r\n  constructor(name, mode) {\r\n    super(`Attempted to call ${name} while edge was in stage ${mode}`);\r\n    this.name = \"ColorError\";\r\n  }\r\n}\r\n// Is the background of an edge a solid color or gradient right now?\r\nenum BackgroundMode {\r\n  Solid,\r\n  Gradient\r\n}\r\ninterface EdgeProps {\r\n    p1: Vertex,\r\n    p2: Vertex,\r\n    color1: string,\r\n    color2: string,\r\n    // props: vertices it belongs to, and colors it should start with.\r\n  }\r\n\r\n  interface EdgeState {\r\n    clipState: number;\r\n    color1: string,\r\n    color2: string,\r\n    backgroundMode: BackgroundMode,\r\n  }\r\n  \r\n  class Edge extends React.Component<EdgeProps, EdgeState> {\r\n\r\n    private clipStates: string[] = [];\r\n    private w: number;\r\n    private h: number;\r\n    private length: number;\r\n    private left: number;\r\n    private top: number;\r\n    private angle: number;\r\n    // These are properties of the Edge class itself, not the state. This distinction is made because these\r\n    // variables are only generated once, internally, and the component does not need to react to their modification\r\n\r\n    static default(p1: Vertex, p2: Vertex) {\r\n      return new Edge({\r\n        p1, p2,\r\n        backgroundMode: BackgroundMode.Solid,\r\n        color1: Color.Default,\r\n        color2: Color.Default,\r\n      });\r\n\r\n      // Default edges should be Default color.\r\n    }\r\n\r\n\r\n    constructor (props) {\r\n      super(props);\r\n      // Should start as a \"defualt\" edge - grey and inactive.\r\n      this.state = {\r\n        clipState: 0,\r\n        color1: props.color1,\r\n        color2: props.color2,\r\n        backgroundMode: BackgroundMode.Solid,\r\n      }\r\n      // We use createRef to get access to particular HTML elements for our render function\r\n      // apparently bad practice but whatever \r\n\r\n      this.colorRef = React.createRef();\r\n      const {p1, p2} = props;\r\n      // Calculating transform properties of the Edge position on screen.\r\n      this.w = p2.props.p.x - p1.props.p.x;\r\n      this.h = p2.props.p.y - p1.props.p.y;\r\n      this.length = Math.hypot(this.w, this.h);\r\n      this.left = p1.props.p.x;//Math.min(x1, x2);\r\n      this.top = p1.props.p.y;//Math.min(y1, y2);\r\n      this.angle = Math.atan2(this.h, this.w) * 180 / Math.PI;// * Math.sign(h);\r\n\r\n      const l  = this.length;\r\n      this.clipStates = [\r\n        // These represent the keyframes between which the CSS engine should animate\r\n        // a large (> Math.PI / 3) value for an angle means that side will be \"fatter\".\r\n\r\n        makePath(Math.PI / 6, Math.PI / 6, l * 0.5, l, 30, 3),\r\n        makePath(Math.PI * 2 / 5, Math.PI / 6, l * 0.8, l, 30, 5),\r\n        makePath(Math.PI / 6, Math.PI * 2 / 5, l * 0.3, l, 30, 5),\r\n        makePath(Math.PI * 2 / 5, Math.PI * 2 / 5, l * 0.5, l, 30, 10),\r\n      ]\r\n    }\r\n    // When the component is created. make sure it's in the default clip state (dormant and thin)\r\n    componentDidMount() {\r\n      console.log(\"mounted\");\r\n      this.setClipState(0);\r\n    }\r\n\r\n    colorRef;\r\n    //Helper functions\r\n    getIndex1() : number {\r\n      return this.props.p1.state.index1;\r\n    }\r\n\r\n    getIndex2(): number {\r\n      return this.props.p2.state.index1;\r\n    }\r\n\r\n    // The css gives particular CSS properties transition times. However, sometimes they need\r\n    // to be done instantly. styleInstantly takes a function with style changes to be run, adds a \"notransition\" class\r\n    // which removes all transitions and timing, runs the function, and removes the notransition class.\r\n    \r\n    styleInstantly(el: HTMLElement, f: Function) {\r\n      // https://stackoverflow.com/questions/11131875/what-is-the-cleanest-way-to-disable-css-transition-effects-temporarily\r\n      el.classList.add('notransition');\r\n      f();\r\n      let x = el.offsetHeight;\r\n      el.classList.remove('notransition');\r\n    }\r\n      /*Solid(1) fades to Solid(2);\r\n      Solid(1) swipes to Solid(2)\r\n      Solid(1) reverse swipes to Solid(2);\r\n      Solid(x) fades to Gradient(x, y)\r\n      Solid(y) fades to Gradient(x, y)\r\n      Solid(x) swipes to Gradient(x y)\r\n      Solid(y) swipes to Gradient(x, y)\r\n      Gradient(x, y) fades to Solid(x)\r\n      Gradient(x, y) fades to Solid(y)\r\n      Gradient(x, y) swipes to Solid(x)\r\n      Gradient(x, y) swipes to Gradient(x) \r\n      Gradient(x, y) fades to Gradient(z, y)\r\n      Gradient(x, y) fades to Gradient(x, z);*/\r\n\r\n    // Removes the background  image. updates the state.\r\n    fadeToSolid(color1: string) {\r\n      const lineDiv = this.colorRef.current.querySelector('.edge_inner');\r\n      \r\n      this.styleInstantly(lineDiv, () => {\r\n        lineDiv.style.backgroundImage = \"none\";\r\n      })\r\n      //this.setState({clipState})\r\n    }\r\n    \r\n    //  Modifies the way the edge_inner looks, and updates the Edge state.\r\n    setClipState(clipState: number) {\r\n      const lineDiv = this.colorRef.current.querySelector('.edge_inner');\r\n      lineDiv.style.clipPath = this.clipStates[clipState];\r\n      this.setState({clipState})\r\n    }\r\n    // Creates our \"sweep\" gradient who's x position we animate \r\n    makeGradientString(color1: string, color2: string) : string {\r\n      return `linear-gradient(90deg, ${color2} 0%, ${color2} 33%, ${color1} 67%, ${color1} 100%)`;\r\n    }\r\n\r\n    // Reset every property when we begin an animation.\r\n    reset() {\r\n      this.fadeToSolid(Color.Default);\r\n      this.setState({backgroundMode: BackgroundMode.Solid, color1: Color.Default});\r\n      //this.sweepForward(Color.Default, Color.Default);\r\n      this.setState({\r\n        color1: Color.Default,\r\n        color2: Color.Default,\r\n        backgroundMode: BackgroundMode.Solid,\r\n      })\r\n    }\r\n    // Execute a \"sweep\" animation\r\n    sweepForward(speed: number, color1: string, color2: string) : void {\r\n      // Error handling\r\n      if (this.state.backgroundMode == BackgroundMode.Gradient) {\r\n        throw new ColorError(\"moveForward\", this.state.backgroundMode);\r\n      }\r\n\r\n    \r\n      const gradient = this.makeGradientString(color1, color2);\r\n      const newBG = {\r\n        backgroundImage: gradient,\r\n      }\r\n      const lineDiv = this.colorRef.current.querySelector('.edge_inner');\r\n      if ( !lineDiv ) return;\r\n\r\n      // Set the position to the \"beginning\" of the gradient. This should be a seamless transition\r\n      // from the edge just being that solid color.\r\n      this.styleInstantly(lineDiv, () => {\r\n        lineDiv.style.backgroundImage = gradient;\r\n        lineDiv.style.backgroundPositionX = \"100%\";\r\n      });\r\n      // large left side\r\n      this.setClipState(1);\r\n      lineDiv.style.backgroundPositionX = \"66%\";\r\n      // some new color peeks in\r\n\r\n      const onComplete = () => {\r\n        this.styleInstantly(lineDiv, () => {\r\n          // when we end up fully in color2 of the gradient, set\r\n          // this edge to just be solid, and only \"that color\".\r\n          lineDiv.style.backgroundImage = color2;\r\n          lineDiv.style.backgroundPositionX = \"0%\";\r\n        });\r\n        // set the state to reflect this.\r\n        this.setState({backgroundMode: BackgroundMode.Solid, color1: color2});\r\n      }\r\n\r\n      window.setTimeout(() => {\r\n        // both sides big (middle ground)\r\n        this.setClipState(2);\r\n        // Gradient, begin sweeping over to other side\r\n        lineDiv.style.backgroundPositionX = \"0%\";\r\n        window.setTimeout(() => {\r\n          // and back to normal\r\n          this.setClipState(0);\r\n          window.setTimeout(onComplete, SPEED*7/3);\r\n        }, SPEED);\r\n      }, SPEED);\r\n\r\n      \r\n      \r\n      \r\n      \r\n    }\r\n  \r\n    render() {\r\n      // Get and apply position values\r\n      const {top, left, length, angle} = this;\r\n      // transform information\r\n      const styleMain = {\r\n        top, left, width: `${length}px`,\r\n        transform: `rotate(${angle}deg)`,\r\n        borderWidth: \"0px\",\r\n        borderColor: this.state.color1,\r\n      }\r\n\r\n      let styleInner;\r\n      const color1 = this.state.color1;\r\n      const color2 = this.state.color2;\r\n      // We need to render styles differently based on whether the current edge is in Solid or Gradient mode.\r\n      if (this.state.backgroundMode == BackgroundMode.Solid) {\r\n        // most of the time, it seems\r\n        styleInner = { backgroundColor: this.state.color1 };\r\n      } else if (this.state.backgroundMode == BackgroundMode.Gradient) {\r\n        styleInner = { backgroundImage: `linear-gradient(90deg, ${color1} 0%, ${color1})33%, {color2}67%, ${color2}100%`}\r\n      }\r\n    \r\n      styleInner.clipPath = this.clipStates[this.state.clipState];\r\n      \r\n      return (\r\n        <div key={\"vertex\" + this.props.p1.state.index1 + \"/\" + this.props.p2.state.index1}  ref={this.colorRef}  className=\"edge\" style={styleMain}>\r\n          <div className=\"edge_arrow\"></div><div className=\"edge_inner\" style={styleInner}></div>    \r\n        </div>\r\n      )\r\n    }\r\n  \r\n  \r\n  }\r\n\r\n  export {\r\n    Edge,\r\n    BackgroundMode\r\n  }\r\n\r\n","enum AnimationType {\r\n    SweepForward, SweepBackward, Fade, FadeVertex, Wait\r\n  }\r\n  \r\n\r\ninterface StepEntry {\r\n    time: number;\r\n    index1: number;\r\n    index2?: number;\r\n    color1: string;\r\n    color2?: string;\r\n    animationType: AnimationType;\r\n    \r\n  }\r\n  interface Step {\r\n    frames: StepEntry[];\r\n  }\r\n\r\n  class StepMaker {\r\n    \r\n  }\r\n  export { AnimationType }\r\n  export type { StepEntry, Step}","import { timeStamp } from 'console';\r\nimport React from 'react';\r\n\r\n\r\n// Board passes down an object through which we are able to modify\r\n// the Board state.\r\ninterface GUIProps {up: {set: Function, run: Function}} \r\ninterface GUIState {mode: string, speed: number}\r\n\r\nclass GUI extends React.Component<GUIProps, GUIState> {\r\n  constructor (props: any) { \r\n    super(props);\r\n    \r\n    this.state = {\r\n      mode: \"EDIT\",\r\n      speed: 1,\r\n    }    \r\n  }\r\n\r\n  onclick_editmode = (e) => {\r\n    this.props.up.set('editmode', e.target.textContent.toUpperCase())\r\n  }\r\n\r\n  onclick_mode = e => {\r\n    this.setState({mode: e.target.textContent.toUpperCase()});\r\n    this.props.up.set('mode', e.target.textContent.toUpperCase());\r\n  }\r\n\r\n  onclick_runmode = e => {\r\n    this.props.up.set('testmode', e.target.textContent.toUpperCase());\r\n  }\r\n\r\n  onclick_run = (e) => {\r\n    this.props.up.run();\r\n  }\r\n\r\n  onclick_speed = (e) => {\r\n    let speed = (this.state.speed + 1) % 3;\r\n    this.setState({speed});\r\n    this.props.up.set('speed', speed);\r\n    let speedMS = 0.5 - 0.12 * speed - 0.03 * speed * speed;\r\n    document.documentElement.style.setProperty('--transition-time',  speedMS + \"s\");\r\n  }\r\n\r\n  render() {\r\n    let guiEditStyle = {\r\n      \r\n    }\r\n    return (\r\n      <div className=\"guiOuter\">\r\n        <div className={\"guiCategory guiEdit \" + (this.state.mode == \"EDIT\" ? \"\" : \"disable\")}>\r\n          <div className=\"clickElement\" onClick={((e) => this.onclick_editmode(e))}>New</div>\r\n          <div className=\"clickElement\" onClick={this.onclick_editmode}>Delete</div>\r\n          <div className=\"clickElement\" onClick={this.onclick_editmode}>Connect</div>\r\n          <div className=\"clickElement\" onClick={this.onclick_editmode}>Set Start</div>\r\n          <div className=\"clickElement\" onClick={this.onclick_editmode}>Set Goal</div>\r\n        </div>\r\n        <div className=\"guiCategory guiMode\">\r\n          <div className=\"clickElement clickMedium\" onClick={this.onclick_mode}>Edit</div>\r\n          <div className=\"clickElement clickMedium\" onClick={this.onclick_mode}>Test</div>\r\n        </div>\r\n        <div className={\"guiCategory guiTest \" + (this.state.mode == \"TEST\" ? \"\" : \"disable\")}>\r\n          <div className=\"clickElement\" onClick={this.onclick_runmode}>DFS</div>\r\n          <div className=\"clickElement\" onClick={this.onclick_runmode}>BFS</div>\r\n          <div className=\"clickElement clickImportant\" onClick={(e) => this.onclick_run(e)}>Run</div>\r\n          <div className=\"clickElement\" onClick={this.onclick_speed}>{\"Speed: \" + this.state.speed}</div>\r\n        </div>\r\n      </div>\r\n    \r\n    )\r\n  }\r\n}\r\n\r\nexport default GUI;","import { EEXIST } from 'constants';\r\nimport { Edge } from './Edge';\r\nimport Color from './Color';\r\nimport { AnimationType, StepEntry, Step} from './Step';\r\nimport { PassThrough } from 'stream';\r\nimport { format } from 'path';\r\ninterface GraphData {\r\n    edgeInfo: number[][];\r\n    size: number;\r\n}\r\nclass Graph implements GraphData {\r\n\r\n    size: number;\r\n    edgeInfo: number[][];\r\n    constructor(edges: Edge[][]) {\r\n        this.edgeInfo = edges.map((row: Edge[]) => {\r\n            return row.map((e: Edge) => {\r\n                return e.getIndex2();\r\n            });\r\n        })\r\n        this.size = edges.length;\r\n    }\r\n\r\n    /*\r\n        The graph class stores the transition table and it's size as properties. \r\n        When we run algorithms, we acess the board through 'this'\r\n        The return value of any algorithm function should be an array of steps. Each step represents one \"action\". \r\n        */\r\n     \r\n    fadeVertex(time: number, index1: number, color1: string) : Step {\r\n        return {\r\n            frames: [\r\n                {\r\n                    time, index1, color1, animationType: AnimationType.FadeVertex,\r\n                }\r\n            ]\r\n        }\r\n    }\r\n    /*runBreadthFirstSearch(time: number, start: number, goal: number, color: string) : Step[] {\r\n        console.log(\"running\");\r\n        if ((!this.edgeInfo[start]) || start < 0 || start > this.size) {\r\n            throw Error(\"fill in\");\r\n        }\r\n\r\n        const seen: number[] = [start];\r\n        const queue: number[] = [start];\r\n        let steps: Step[] = [this.fadeVertex(time, start, color)];\r\n        while (queue.length) {\r\n            let from = queue.pop() as number;\r\n            this.edgeInfo[from].forEach((to: number) => {\r\n                if (seen.indexOf(to) < 0) {\r\n                    seen.push(to);\r\n                    let s: Step =  {\r\n                        frames: [\r\n                            {\r\n                                time,\r\n                                index1: from,\r\n                                index2: to,\r\n                                color1: color,\r\n                                color2: Color.Red,\r\n                                animationType: AnimationType.SweepForward,\r\n                            }\r\n                        ]\r\n                    };\r\n                    steps.push(s);\r\n                   queue.unshift(to);\r\n                }\r\n            })\r\n        }\r\n        return steps;\r\n    }*/\r\n\r\n    runDepthFirstSearch(time: number, start: number,  goal: number, color: string) : Step[]{\r\n\r\n        if ((!this.edgeInfo[start]) || start < 0 || start > this.size) {\r\n            throw Error(\"fill in\");\r\n        }\r\n\r\n        const seen: number[] = [start];\r\n        const stack: number[] = [start];\r\n        let next;\r\n        let steps: Step[] = [this.fadeVertex(time, start, color)];\r\n\r\n\r\n        let doSearch = (from: number, goal: number, steps: Step[], stack:number[], output: number[][]) : void => {\r\n            //let paths: number[][] = [];\r\n            let returnVal: number[] = [];\r\n            this.edgeInfo[from].forEach((to: number) => {\r\n                let newStack = [...stack, to];\r\n                if (seen.indexOf(to) < 0) {\r\n                    seen.push(to);\r\n                    let s: Step =  {\r\n                        frames: [\r\n                            {\r\n                                time,\r\n                                index1: from,\r\n                                index2: to,\r\n                                color1: color,\r\n                                color2: Color.Red,\r\n                                animationType: AnimationType.SweepForward,\r\n                            }\r\n                        ]\r\n                    };\r\n                    steps.push(s);\r\n                    if (to == goal) {\r\n                        output.push(newStack);\r\n                    }\r\n                    doSearch(to, goal, steps, newStack, output);\r\n                    //([from, ...doSearch(to, goal, steps)]);\r\n                \r\n                }\r\n            });\r\n            \r\n            //return paths.find((arr: number[]) => arr.length > 0) || [];\r\n        }    \r\n        let results: number[][] = []\r\n        doSearch(start, goal, steps, [start], results);\r\n        let found: number[] = results[0] || [];\r\n        steps.push(this.fadeVertex(time, start, Color.Green));\r\n        for (let i = 0; i < found.length - 1; i++) {\r\n            let s: Step = {\r\n                frames: [{\r\n                    time,\r\n                    index1: found[i],\r\n                    index2: found[i+1],\r\n                    color1: Color.Green,\r\n                    color2: Color.Red,\r\n                    animationType: AnimationType.SweepForward,\r\n                }]\r\n            };\r\n\r\n            steps.push(s);\r\n        }\r\n        console.log(found);\r\n        return steps;\r\n        \r\n    }\r\n\r\n    runBreadthFirstSearch(time: number, start: number,  goal: number, color: string) : Step[]{\r\n\r\n        if ((!this.edgeInfo[start]) || start < 0 || start > this.size) {\r\n            throw Error(\"fill in\");\r\n        }\r\n\r\n        const seen: number[] = [start];\r\n        const stack: number[] = [start];\r\n        let next;\r\n        let steps: Step[] = [this.fadeVertex(time, start, color)];\r\n\r\n\r\n        let doSearch = (from: number, goal: number, steps: Step[], stack:number[], output: number[][]) : void => {\r\n            //let paths: number[][] = [];\r\n            let returnVal: number[] = [];\r\n            let tos: any[] = [];\r\n            this.edgeInfo[from].forEach((to: number) => {\r\n                let newStack = [...stack, to];\r\n                if (seen.indexOf(to) < 0) {\r\n                    seen.push(to);\r\n                    let s: Step =  {\r\n                        frames: [\r\n                            {\r\n                                time,\r\n                                index1: from,\r\n                                index2: to,\r\n                                color1: color,\r\n                                color2: Color.Red,\r\n                                animationType: AnimationType.SweepForward,\r\n                            }\r\n                        ]\r\n                    };\r\n                    steps.push(s);\r\n                    if (to == goal) {\r\n                        output.push(newStack);\r\n                    }\r\n                    tos.push(to);\r\n                    \r\n                    //doSearch(to, goal, steps, newStack, output);\r\n                    //([from, ...doSearch(to, goal, steps)]);\r\n                \r\n                }\r\n            });\r\n            tos.forEach((to: number) => {\r\n                doSearch(to, goal, steps, [...stack, to], output);\r\n            })\r\n            \r\n            //return paths.find((arr: number[]) => arr.length > 0) || [];\r\n        }    \r\n        let results: number[][] = []\r\n        doSearch(start, goal, steps, [start], results);\r\n        let found: number[] = results[0] || [];\r\n        steps.push(this.fadeVertex(time, start, Color.Green));\r\n        for (let i = 0; i < found.length - 1; i++) {\r\n            let s: Step = {\r\n                frames: [{\r\n                    time,\r\n                    index1: found[i],\r\n                    index2: found[i+1],\r\n                    color1: Color.Green,\r\n                    color2: Color.Red,\r\n                    animationType: AnimationType.SweepForward,\r\n                }]\r\n            };\r\n\r\n            steps.push(s);\r\n        }\r\n        console.log(found);\r\n        return steps;\r\n    }\r\n}\r\nexport default Graph;","import React, { ReactElement } from 'react';\r\nimport { Edge, BackgroundMode } from './Edge';\r\nimport { Vertex } from './Vertex';\r\nimport GUI from './GUI';\r\nimport Graph from './Graph';\r\nimport { AnimationType, StepEntry, Step} from './Step';\r\nimport Color from './Color';\r\nimport VertexColor from './VertexColor';\r\nimport { stringify } from 'querystring';\r\nimport { getJSDocReadonlyTag, readBuilderProgram } from 'typescript';\r\nimport { NONAME } from 'dns';\r\n\r\n\r\n// Constants (not board size i guess)\r\n\r\nlet BOARD_SIZE = 1000;\r\nconst VERTEX_RADIUS = 50;\r\nconst PADDING_SIZE = 5;\r\n\r\nfunction copy<T>(obj: T) : T {\r\n  return JSON.parse(JSON.stringify(obj));\r\n}\r\n\r\ndeclare global {\r\n  interface Promise<T> {\r\n    delay(t: number): any;\r\n  }\r\n}\r\n// https://stackoverflow.com/questions/39538473/using-settimeout-on-promise-chain\r\n// from stack overflow - a promise based method to delay animations\r\nfunction delay(t, v) {\r\n  return new Promise(function(resolve) { \r\n      setTimeout(resolve.bind(null, v), t)\r\n  });\r\n}\r\n\r\nPromise.prototype.delay = function(t) {\r\n  return this.then(function(v) {\r\n      return delay(t, v);\r\n  });\r\n}\r\n\r\n// get coords relative to my Board div. used for placing vertices.\r\nconst getRelativeCoords = function(e: React.MouseEvent){\r\n    // source: https://stackoverflow.com/questions/3234256/find-mouse-position-relative-to-element\r\n    const el = document.querySelector('.board') as Element;\r\n    \r\n    \r\n    const event = e.nativeEvent;\r\n    const target = event.target as HTMLElement;\r\n\r\n\r\n    const rect = target.getBoundingClientRect();\r\n\r\n    const position = {\r\n      x: event.pageX,\r\n      y: event.pageY,\r\n    };\r\n  \r\n    const offset = {\r\n      left: rect.x,\r\n      top: rect.y\r\n    };\r\n  \r\n    return { \r\n      x: event.clientX- rect.x,\r\n      y: event.clientY - rect.y,\r\n    }; \r\n  \r\n}\r\n\r\n// Board settings - are we testing or editing? sub modes (add, connect, delete, etc)\r\ninterface BoardSettings {\r\n  mode: string,\r\n  editmode: string,\r\n  testmode: string,\r\n  speed: number,\r\n}\r\n\r\n// Each board has vertices, edges, and start and settings.\r\ninterface BoardState {\r\n  vertices: Vertex[];\r\n  edges: Edge[][];\r\n  start: number;\r\n  goal: number;\r\n  settings: BoardSettings;\r\n}\r\n\r\n// Nothing is passed into board so props are empty!!!\r\ninterface BoardProps { };\r\n\r\nclass Board extends React.Component<BoardProps, BoardState> {\r\n\r\n  static interpretMouseEvent = function(e: React.MouseEvent) {\r\n    const {x, y} = getRelativeCoords(e);\r\n    // Get coordinates reative to the board\r\n    const index = e.target;\r\n    // maybe delete i think\r\n    const id = e[\"vertexId\"];\r\n    // get the ID of the clicked vertex.\r\n    let validLocation = Board.isValidLocation(x, y);\r\n    // Is within bounds?\r\n    let hitSpacer = Boolean(e[\"hitSpacer\"]);\r\n    // did we hit a \"spacer\" (to provide room. no overlap)\r\n    let hitVertex = id !== undefined;\r\n    // duh\r\n    return {\r\n      x, y, hitSpacer, hitVertex, id, validLocation,\r\n    }\r\n  }\r\n  constructor(props: any) {\r\n    super(props);\r\n    // Make sure all update seting and helper functions are bound to current context so they can be passed to GUI.\r\n    [\"addVertex\", \"deleteVertex\", \"updateSetting\", \"addEdge\", \"deleteEdge\", \"run\"].forEach((fnName: string) => {\r\n      this[fnName] = this[fnName].bind(this);\r\n    }); // Bind all functions that are passed to child components to 'Board' this\r\n\r\n    this.state = {\r\n      vertices: [],\r\n      edges: [],\r\n      settings: {\r\n        mode: \"EDIT\",\r\n        editmode: \"NEW\",\r\n        testmode: \"DFS\",\r\n        speed: 1,\r\n      },\r\n      start: 0,\r\n      goal: -1,\r\n    };\r\n\r\n    this.mouseDownVertexId = -1;\r\n    \r\n  }\r\n  settings; mouseDownVertexId = -1;\r\n\r\n  /// Retreives and passes settings up to be set on the board state.\r\n  updateSetting (key: string, value: string) {\r\n    const newSettings = copy<BoardSettings>(this.state.settings);\r\n    // newSettings is now origional state plus edit\r\n    Object.assign(newSettings, {[key]: value});\r\n\r\n    this.setState({settings: newSettings}, () => {\r\n      console.log(`Update set on prop ${key}: ${this.state.settings[key]}`)\r\n    });\r\n    \r\n  }\r\n\r\n  componentDidMount() {\r\n    BOARD_SIZE = window.innerWidth;\r\n  }\r\n\r\n  static isValidLocation(x: number, y: number) {\r\n    let outBox = [x, y].some(dim => dim < (PADDING_SIZE + VERTEX_RADIUS) || dim > (BOARD_SIZE - PADDING_SIZE - VERTEX_RADIUS));\r\n    return !(outBox);\r\n  }\r\n\r\n  setStart(v: number) : void {\r\n    const prevStart = this.state.start;\r\n    const prevStartVertex = this.getVertex(prevStart);\r\n    if (prevStartVertex) prevStartVertex.setState({isStart: false});\r\n    this.setState({start: v});\r\n    this.getVertex(v).setStart();/*setState({isStart: true}, function() {\r\n      console.log(\"Set state\");\r\n    });*/\r\n  }\r\n\r\n  setGoal(v: number) : void {\r\n    const prevGoal = this.state.goal;\r\n    const prevgoalVertex = this.getVertex(prevGoal);\r\n    if (prevgoalVertex) prevgoalVertex.setState({isGoal: false});\r\n    this.setState({goal: v});\r\n    this.getVertex(v).setGoal();/*setState({isgoal: true}, function() {\r\n      console.log(\"Set state\");\r\n    });*/\r\n  }\r\n\r\n  onmousedown(event: React.MouseEvent) : void {\r\n\r\n    const {x, y, hitSpacer, hitVertex, id, validLocation} = Board.interpretMouseEvent(event);\r\n\r\n    // When we receive a mouse down event, we decide what to do based on the current bord state.\r\n    const mode: string = this.state.settings[\"mode\"];\r\n    if (mode == 'EDIT') {\r\n        switch (this.state.settings[\"editmode\"]) {\r\n            case 'NEW':\r\n              if (validLocation && !hitSpacer) this.addVertex(x, y); \r\n              break;\r\n            case 'DELETE':\r\n              if (hitVertex) this.deleteVertex(id); \r\n              break;\r\n            case 'CONNECT':\r\n              if (hitVertex) this.mouseDownVertexId = id;\r\n              break;\r\n            case 'SET START':\r\n              if (hitVertex) this.setStart(id);\r\n              break;\r\n            case 'SET GOAL':\r\n              if (hitVertex) this.setGoal(id);\r\n              break;  \r\n            default: break;\r\n          }\r\n    } else if (mode == 'TEST') {\r\n        //console.log(\"Edges\", this.state.edges);\r\n        //const colors = [\"red\", \"yellow\", \"blue\", \"grey\", \"green\", \"black\"];\r\n    } else {\r\n        console.log(\"unknown board mode\");\r\n    }\r\n    \r\n  }\r\n  // Helper functions\r\n  getAllVertices() : Vertex[] {\r\n    return [...this.state.vertices];\r\n  }\r\n  getAllEdges() : Edge[] {\r\n    return [...this.state.edges.flat().filter(Boolean)];\r\n  }\r\n  private getVertex(index1: number) : Vertex {\r\n    return this.state.vertices[index1];\r\n  }\r\n\r\n  private getEdge(index1: number, index2: number) : Edge {\r\n    return this.state.edges[index1][index2];\r\n  }\r\n\r\n  private getStart() : Vertex {\r\n    return this.getVertex(this.state.start);\r\n  }\r\n\r\n  private getGoal() : Vertex {\r\n    return this.getVertex(this.state.goal);\r\n  }\r\n\r\n\r\n  onmouseup(event: React.MouseEvent) : void {\r\n\r\n    const {x, y, hitSpacer, hitVertex, id, validLocation} = Board.interpretMouseEvent(event);\r\n    const mode: string = this.state.settings[\"mode\"];\r\n    // Once again, we decide what to do with a mouse up event based on the current Board state.\r\n    if (mode == 'EDIT') {\r\n        switch (this.state.settings[\"editmode\"]) {\r\n        case 'CONNECT':\r\n            if (hitVertex) {\r\n            const from = this.mouseDownVertexId;\r\n            const to = id;\r\n\r\n            this.addEdge(from, to);\r\n            break;\r\n            }\r\n        }\r\n    } else if (mode == 'TEST') {\r\n      return; // not needed\r\n    }\r\n  } \r\n\r\n  // Add a vertex to the board\r\n  addVertex(x: number, y: number) : Vertex {\r\n   \r\n    const position = this.state.vertices.length;\r\n    // get new vertex idex.\r\n    let vertices = this.state.vertices;\r\n    let edges = this.state.edges;//copy<Edge[][]>(this.state.edges);\r\n\r\n    const v = Vertex.default(position, x, y);\r\n    // Create new. add it to the vertex list.\r\n    vertices.push(v);\r\n    // give it an edge list.\r\n    edges.push([]);\r\n    \r\n    this.setState({vertices, edges})\r\n\r\n    return v;\r\n  }\r\n  // This function barely works. Try not to delete vertices if not needed.\r\n  deleteVertex(index: number) : void {\r\n    const vertices = this.state.vertices; // get the current vertexs\r\n    const edges = this.state.edges; \r\n    vertices.splice(index, 1); // Remove the proper index\r\n    edges.splice(index, 1); // remove proper index\r\n    const length = vertices.length;\r\n    for (let i = index; i <  length; i++) {\r\n      // Reindex all the values on other vertices so that everything is still right\r\n      vertices[i].decrementIndex() \r\n      edges[i] = edges[i].map((edge: Edge, j) => (edge.getIndex1() >= index) ? edges[i][j+1] : edge);\r\n      \r\n    }\r\n    this.setState({vertices, edges}); // set the new ones \r\n  }\r\n  \r\n  addEdge(index1: number, index2: number) : void{\r\n    const edges = this.state.edges;\r\n    const row = edges[index1];\r\n    const el = row[index2];\r\n    if (el !== undefined) return; // make sure there's not an edge already there\r\n    row[index2] = Edge.default(this.getVertex(index1), this.getVertex(index2));\r\n    this.setState({edges}, () => {\r\n      console.log(\"new edges area: \", this.state.edges)\r\n    });\r\n  }\r\n\r\n  deleteEdge(index1: number, index2: number) : void  {\r\n\r\n  }\r\n  renderVertices() {\r\n    return this.state.vertices.map\r\n    (\r\n      (vertex: Vertex) => vertex.render()\r\n    );\r\n  }\r\n  \r\n  // Render the edges\r\n  renderEdges() {\r\n    return this.state.edges.map\r\n    (\r\n      (tos: Edge[]) => tos.map((edge: Edge) => edge.render())\r\n    ).flat()\r\n  }\r\n// Creates an \"all\" wrapper promise which resolves when all substeps are done.\r\n  animateStep(step: Step, speed: number) {\r\n    return Promise.all<void>(step.frames.map((entry: StepEntry) => {\r\n      return this.animateStepEntry(entry, speed);\r\n    }));\r\n  }\r\n\r\n  // We use promises to manage the asynchronous activity nessecary for animations.\r\n  animateStepEntry(entry: StepEntry, speed: number) {\r\n    switch (entry.animationType) {\r\n      case AnimationType.SweepForward:\r\n        return new Promise<void>((resolve, reject) => {\r\n          this.doSweep(speed, entry.index1, entry.index2 || 0, entry.color1, entry.color2 || \"something has gone wrong\");\r\n          resolve();//setTimeout(() => resolve(), 400);\r\n        });\r\n      case AnimationType.FadeVertex: \r\n        return new Promise<void>((resolve, reject) => {\r\n          this.fadeVertex(entry.index1, entry.color1);\r\n          resolve();\r\n        });\r\n      default:\r\n        return Promise.resolve();\r\n    }\r\n  }\r\n\r\n  animateSteps(steps: Step[]) {\r\n    //steps.reduceRight((current, step) => current.then(this.animateStep(step)), Promise.resolve())\r\n    \r\n    steps.reduce((curr, step) => {\r\n      const time = Math.max.apply(null, step.frames.map((frame: StepEntry) => frame.time));\r\n      return curr.then(() => this.animateStep(step, this.state.settings.speed).delay(time *  5 / 3))\r\n    }, Promise.resolve())\r\n  }\r\n \r\n  // REset everything when we run a new animation\r\n  reset() {\r\n    this.getAllEdges().forEach(edge => edge.reset());\r\n    this.getAllVertices().forEach(vertex => vertex.reset());\r\n  }\r\n  run() {\r\n\r\n    console.log(\"VERTICES\", this.state.vertices);\r\n    console.log(this.state);\r\n    this.reset();\r\n    const graph = new Graph(this.state.edges);\r\n    console.log(graph);\r\n    let steps: Step[];\r\n    const time = 500 - this.state.settings.speed * 200;\r\n    if (this.state.goal  < 0) return;\r\n    switch (this.state.settings[\"testmode\"]) {\r\n      case 'DFS':\r\n        steps = graph.runDepthFirstSearch(time, this.state.start, this.state.goal, Color.Black); break;\r\n      case 'BFS':\r\n        steps = graph.runBreadthFirstSearch(time, this.state.start, this.state.goal, Color.Black); break;\r\n      default:\r\n      break;\r\n    }\r\n    //this.getVertex(this.state.start).fadeTo(Color.Black);\r\n    Promise.resolve().then(resolve => this.animateSteps(steps));\r\n  \r\n  }\r\n  \r\n  fadeVertex(index1: number, color: string) : void {\r\n    let v: Vertex = this.getVertex(index1);\r\n    v.fadeTo(color);\r\n  }\r\n\r\n  // To create a \"sweep\" effect, we not only have to call methods on Edge and Vertex to animate it,\r\n  // we must also change the state of Board, Edge, and Vertex to reflect hte change.\r\n  doSweep(speed: number, index1: number, index2: number, color1: string, color2: string) {\r\n    const v1 = this.getVertex(index1);\r\n    const v2 = this.getVertex(index2);\r\n    console.log(\"sweep vertices\", {v1, v2})\r\n    const edge = this.getEdge(index1, index2);\r\n\r\n    this.animateSweep(speed, edge, v1.state.color, color1);\r\n    Promise.resolve().delay(speed * 0.7).then(resolve => v2.fadeTo(color1));\r\n  }\r\n\r\n  animateSweep(speed: number, edge: Edge, color1: string, color2: string) {\r\n    edge.sweepForward(speed, color1, color2);\r\n  }\r\n\r\n  render() {\r\n\r\n    let start = this.getStart()?.props?.p;\r\n    let goal = this.getGoal()?.props?.p;\r\n    return (\r\n    <div className=\"board\">\r\n      <GUI up={{set: this.updateSetting, run: this.run}} />\r\n      <div className = \"boardDisplay\"  \r\n        onMouseDown={(e: React.MouseEvent) => this.onmousedown(e)}\r\n        onMouseUp={(e: React.MouseEvent) => this.onmouseup(e)}\r\n      >\r\n        { [...this.renderVertices(), ...this.renderEdges()] }\r\n        <div className=\"start_box box\" style={{\r\n          display: start ? \"inherit\" : \"none\",\r\n          left: start?.x - 37 || 0,\r\n          top: start?.y - 37 || 0,\r\n        }}></div>\r\n        <div className=\"goal_box box\" style={{\r\n          display: goal ? \"inherit\" : \"none\",\r\n          left: goal?.x - 37|| 0,\r\n          top: goal?.y - 37 || 0,\r\n        }}></div>\r\n      </div>\r\n    </div>\r\n      )\r\n  }\r\n}\r\n\r\nexport default Board;","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nimport Board from './Board';\nimport { getDefaultCompilerOptions } from 'typescript';\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div className=\"title\">\n        Graph Editor by Justin Lee\n      </div>\n         <Board />\n    </div>\n  );\n}\n\n\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n\n"],"sourceRoot":""}